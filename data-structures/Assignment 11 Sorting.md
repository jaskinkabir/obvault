Jaskin Kabir 801186717
## Problem 1: Count Inversions
### 1.Problem description
Given an unsorted array $A$, count the number of pairs of elements 
$A[i]$ and $A[j]$ that satisfy the condition: $A[i] > A[j] \cap i<j$ 
### 2.Initial solution description
My first step was to code a brute force approach that I knew would work so that I could verify whatever test cases I came up with. I found that such an approach would be $O(n^{2})$ in time complexity, and the assignment requires an $O(n\log n)$ algorithm, so I knew my work wasn't done yet.

Like the given problem description says, my initial thought was to piggyback off of the merge step of the merge sort algorithm. I realized that every time the merge step needed to copy the first element of the right side of the list rather than the left, an inversion must occur. So I wrote the code to scan through the left and right arrays, and increment the number of inversions counted each time the head of the left array was greater than the head of the right array. This approach did not work, so I then watched the second video.

In the video, Prof. Roughgarden showed that the best way to solve this problem was to actually sort the array while counting the inversions. He also showed that each time the head of the right array was less than the head of the left array, the inversion counter should not be incremented by 1, but by the number of elements remaining in the left array. I made these two fixes and the algorithm then produced the proper results.
### 3.AI prompts used
None
### 4. Code explanation. Emphasize high level intuition (include code)
This code initializes two 'pointers' to elements of the left and right arrays generated by the `countInv` function, and another 'pointer' to an element of the full array. It then iteratively checks if the left pointer's value is less than the right pointer's value. If it is, then it will place the left value into the full array at the index pointed to by the full pointer and increment the left pointer and the full pointer. If the right pointer has a lower value than the left, the right value is placed into the full array, and the right pointer is incremented alongside the full pointer. After this, the inversion count is increased by the number of elements remaining in the left array. Finally the remaining elements of the two arrays are placed into the full array to ensure proper sorting.

```cpp
int mergeInv(vector<int>& nums, vector<int>& left, vector<int>& right) {
    int leftIndex = 0;
    int rightIndex = 0;
    int numsIndex = 0;
    
    int inversions=0;
    
    //printVec(right);
    
    while (leftIndex < left.size() && rightIndex < right.size()) {
        
        if (left[leftIndex] <= right[rightIndex]) {
            // Was originally leftIndex++
            nums[numsIndex++] = left[leftIndex++];
            
        }
        else {
            //Was originally rightIndex++
            nums[numsIndex++]=right[rightIndex++];
            //Was originally inversions++;
            inversions += left.size()-leftIndex;
            

        }
    }

    // Copy remaining elements
    while (leftIndex < left.size()) {
        nums[numsIndex++] = left[leftIndex++];
    }

    while (rightIndex < right.size()) {
        nums[numsIndex++] = right[rightIndex++];
    }
    
    return inversions;
}
```
### 5.Code testing (Include test code)
The following testing code produced the expected output.
```cpp
int main()
{
    int n;
    vector<int> numvec{4, 5, 6, 1, 2, 3};
    n = countInv(numvec);
    cout << "Number of inversions " << n << endl; // Should be 9
    
    numvec = {1, 2, 3, 4, 5, 6};
    n = countInv(numvec);
    cout << "Number of inversions " << n << endl; // Should be 0
    
    numvec = {6, 5, 4, 3, 2, 1};
    n = countInv(numvec);
    cout << "Number of inversions " << n << endl;  // Should be 15
    
    numvec = {0, 0, 0, 0, 0, 0};
    n = countInv(numvec);
    cout << "Number of inversions " << n << endl;;  // Should be 0
    
    numvec = {6,3,5,7,8,1,3,2};
    n = countInv(numvec);
    cout << "Number of inversions " << n << endl;;  // Should be 17
}
```
![[Pasted image 20240625164642.png]]
### 6.Alternate solutions if attempted
$O(n^{2})$ brute force algorithm:
```cpp
int countInvOn2(vector<int>& nums) {
    int inversions = 0;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = 0; j < nums.size(); j++) {
            if (nums[i] > nums[j] && i < j) {
                inversions++;
            }
        }
    }
    return inversions;
}
```
## Problem 2: Find Target Indices After Sorting
### 1.Problem description
Given an unsorted array and a target number, find the indices of the array that match the target number after the array is sorted.
### 2.Initial solution description
My intuition was to copy the merge sort algorithm from Problem 1 and implement a search algorithm to find the target indices after sorting. I decided to implement a simple $O(n)$ search instead of a faster binary search for the sake of time. 
### 3.AI prompts used
None
### 4. Code explanation. Emphasize high level intuition (include code)
I removed the lines from Problem 1 that had to do with counting inversions and implemented an $O(n)$ search algorithm to find the target indices.
```cpp
class Solution {

public:

  

vector<int> targetIndices(vector<int>& nums, int target) {
    vector<int> targets;
    mergeSort(nums);

    for (int i = 0; i < nums.size(); i++) {

        if (nums[i] == target) targets.push_back(i);

    }

    return targets;

}

  

void merge(vector<int>& nums, vector<int>& left, vector<int>& right) {

    int leftIndex = 0;

    int rightIndex = 0;

    int numsIndex = 0;

    while (leftIndex < left.size() && rightIndex < right.size()) {

        if (left[leftIndex] <= right[rightIndex]) {

            nums[numsIndex++] = left[leftIndex++];

        }

        else {

            nums[numsIndex++]=right[rightIndex++];

        }

    }

  

    // Copy remaining elements

    while (leftIndex < left.size()) {

        nums[numsIndex++] = left[leftIndex++];

    }

    while (rightIndex < right.size()) {

        nums[numsIndex++] = right[rightIndex++];

    }

}

  
  
  

void mergeSort(vector<int>& nums) {

    // Base case - one element, nothing to sort

  

    if (nums.size() <= 1) return;

    int mid = nums.size()/2;

    //Allocate left and right

    vector<int> left(mid);

    vector<int> right(nums.size()-mid);

  

    //Construct left and right vectors

    copy(nums.begin(), nums.begin() + mid, left.begin());

    copy(nums.begin() + mid, nums.end(), right.begin());

    mergeSort(left);

    mergeSort(right);

    merge(nums, left, right);

}

};
```
### 5.Code testing (Include test code)
I used leetcode for testing, and it worked on the first try so no debugging was required.
![[Pasted image 20240625165047.png]]
### 6.Alternate solutions if attempted

For class #data-structures 