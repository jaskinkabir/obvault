Jaskin Kabir 801186717
## Problem 1: Generating the Directed Graph
### 1.Problem description
Using the openflights data file, create a directed graph with airports as vertices and flights as edges. Each flight listed in the file is directional, so this must be a directed graph.
### 2.Initial solution description
Read through the file and separate each line by commas. Detect the first length 3 string that is entirely capital letters and store it as the source. Detect the second string and store it as the destination. Then add the flight to the adjacency map.
### 3.AI prompts used
None
### 4. Code explanation. Emphasize high level intuition (include code)
This algorithm uses a basic 'state machine' implemented with two DEFINE macros to store state. Every string in the data file that is 3 letters long and made up of capital letters must be an airport. Even the final three letters of the following string won't be detected by this condition because of the newline character at the end: `US,5265,HSV,4113,DCA,3520,,0,CRJ`

I use a unordered map between strings and sets so that the route isn't stored multiple times.
```cpp
#define START 0
#define END 
bool isLetter(char c) {return 'A' <= c && c <= 'Z';}

unordered_map<string, set<string>> getAdjList(string file) {
    ifstream routes(file);
    unordered_map<string, set<string>> routeMap;

    if (!routes.is_open()) {
        cerr << "File opening error!" << endl;
        exit(1);
    }

    string line;

    // Initialize state machine
    bool reading=START;
    string start;
    string end;

    while (getline(routes,line, ',')) {
        // Airport codes are 3 letters
        if (line.length() != 3) continue;
        // Airport codes are all capital letters
        if (!(isLetter(line[0]) && isLetter(line[1]) && isLetter(line[2]) ) ) continue; 

        if (reading==START) {
            start = line;
            reading = END;
        }
        else {
            end = line;
            routeMap[start].insert(end);
            reading=START;
        }


    }

    return routeMap;
}
```
### 5.Code testing (Include test code)
This code was tested by the next two objectives
### 6.Alternate solutions if attempted
None
## Problem 2: Find the Shortest Number of Stops
### 1.Problem description
Given two airport codes, find a flight path with the fewest layovers/connections between them and print this path. 
### 2.Initial solution description
I decided to tackle this problem before the second milestone, because determining if the graph is connected requires the implementation of a search algorithm anyway. I decided to use Breadth First Search for this problem, as it will always find the shortest path between two vertices. I have already implemented this algorithm for assignment 10, so I pasted this code into my new project and applied it to the graph generated by my previously written function. However, this code does not store the paths it found, only the distances.

My initial thought was to store all the vertices the algorithm visits as it moves from the source to the destination, but I quickly realized this wouldn't work, since the algorithm will visit many airports before moving any closer to the destination airport. My solution to this problem was to create another map that stores the parent vertex of every vertex visited by the algorithm in addition to the map that stores the distance from the source. Then, the shortest path can be reconstructed by following the path back to the source.
### 3.AI prompts used
I have a data file that has a list of flights with each line representing oneflight. The only data I care about are the source and destination airports. The source airport is the 3rd string when separating the line by commas and the destination is the 5th. I want a regex that matches the flight from RDU to TPA Ex: FL,1316,RDU,3626,TPA,3646,Y,0,73W
### 4. Code explanation. Emphasize high level intuition (include code)
Most of this code was copied from assignment 10, but with the addition of a 'path' struct that stores the distance and the path rather than just the distance. Alongside this addition was the code that stores the path in the 'parents' map and reconstructs it as a vector using a stack data structure. The stack is used because the shortest path is reconstructed in reverse order, and reading from the stack will reverse it once more to create the path from start to finish. I realize now that a linked list would have been more efficient than a vector for this task, but a vector was easier to use.
```cpp
struct path {
    int distance;
    vector<string> path;
};

path getShortestPath(unordered_map<string, set<string>>& aList, string v1, string v2) {
    path shortestPath;
    shortestPath.distance=-1;

    // Stores shortest distance
    unordered_map<string, int> distanceFromV1;

    // Stores shorest path
    unordered_map<string, string> parents;

    queue<string> toBeExplored;

    // Initialize BFS
    distanceFromV1[v1]=0;
    toBeExplored.push(v1);
    string curVertex;

    // BFS traversal loop
    while (!toBeExplored.empty()) {
        curVertex = toBeExplored.front();
        toBeExplored.pop();

        for (string neighbor : aList[curVertex]) {

            // Ignore already visited nodes
            if (!(distanceFromV1.find(neighbor) == distanceFromV1.end())) continue;
            distanceFromV1[neighbor]=distanceFromV1[curVertex]+1;
            parents[neighbor]=curVertex;
            toBeExplored.push(neighbor);
        }
    }

    shortestPath.distance = distanceFromV1[v2]-1;
    if (shortestPath.distance == -1) return shortestPath;

    stack<string> pathStack;

    curVertex = v2;
    while (curVertex != v1) {
        pathStack.push(curVertex);
        curVertex = parents[curVertex];
    }
    pathStack.push(v1);

    while (!pathStack.empty()) {
        shortestPath.path.push_back(pathStack.top());
        pathStack.pop();
    }
    return shortestPath;
}
```
### 5.Code testing (Include test code)
The testing code uses while loops to ensure that the user inputs a valid airport code, and allows them to try again rather than end the program when invalid input is read. The BFS algorithm is costly, especially with such a dense graph, so memoization is used to ease this burden.
```cpp
template <typename T>
void println(T msg) {
    cout << endl << msg;
}

template <typename T>
void printVec(vector<T> vec) {
    bool start = true;

    for (T n : vec) {
        if (start) start = false;
        else cout << "->";
        cout << n;


    }
    cout << endl;
}

unordered_map<string, path> foundPaths;

path lookupShortestPath(unordered_map<string, set<string>>& aList, string v1, string v2) {
    if (foundPaths.find(v1 + v2)!=foundPaths.end()) return foundPaths[v1+v2];

    path newPath = getShortestPath(aList, v1, v2);

    foundPaths[v1+v2]=newPath;
    return newPath;

}

unordered_map<string, set<string>> routeMap = getAdjList("routes.dat");

int main() {

    unordered_map<string, set<string>> routeMap = getAdjList("routes.dat");
    
    string source;
    while (true) {

        while (true) {
            println("Enter source airport ");
            cin >> source;
            if (routeMap.find(source)==routeMap.end()) {
                println("Invalid source airport code");
            }
            else break;
        }

        string destination;

        while (true) {
            println("Enter destination airport ");
            cin >> destination;
            if (routeMap.find(destination)==routeMap.end()) {
                println("Invalid destination airport code");
            }
            else break;
        }

        path shortestPath = lookupShortestPath(routeMap, source, destination);

        if (shortestPath.distance==-1) {
            cout << "There is no valid path between " << source << " and " << destination << endl; 
        }
        else {

            cout << endl << "The most direct path from " << source << " to " << destination << " requires " << shortestPath.distance << " stop" << (shortestPath.distance == 1 ? "." : "s.") << endl;
            cout << "This path is as follows: ";
            printVec(shortestPath.path);
        }

        cout <<endl;
    }


    return 0;
}

```

Using this code, I first ran a test on the path between RDU and IST. It found the path RDU->IAD->IST, which I confirmed was valid by applying the following regex strings to the routes.dat file: `^[^,]*,[^,]*,RDU,[^,]*,IAD,.*$` and `^[^,]*,[^,]*,IAD,[^,]*,IST,.*$`

To confirm that this was the shortest path possible, I searched using this regex `^[^,]*,[^,]*,RDU,[^,]*,IST,.*$` and found that there is no direct flight between RDU and IST. 
![[Pasted image 20240623214126.png]]
Next, I checked the path between RDU and KZN, which found RDU->IAD->IST->KZN. Using the same regex method as above, I determined that this is a valid flight path, but determining if it is the shortest path required using google flights. Indeed, Google Flights could not find a path between RDU and KZN with 1 or fewer stops, meaning my code had found the most direct path.
![[Pasted image 20240623214107.png]]
![[Pasted image 20240623212650.png]]
The final test was to input RDU and UVE. The openflights database shows that UVE only flies to two other aiports in the country of New Caledonia, so there should be no valid path between these two airports. Sure enough, my code does not return a valid flight path.
![[Pasted image 20240623214140.png]]
### 6.Alternate solutions if attempted
None
## Problem 3: Determine Weak Connection 
### 1.Problem description
Determine whether the directed graph described by the openflights data is weakly connected. This means that for every two airports, there exists a flight between them in at least one direction.
### 2.Initial solution description
My first solution was to iterate over every combination of airports and check if there exists at least one path between them. However, this approach was so slow that I couldn't get it to finish in less than 5 minutes. With 3321 airports, it would have to complete more than 11 million BFS traversals, which was completely infeasible. 

My next solution came to me after I realized that I could simply start from a random airport, and then iterate over all other airports and check if there exists a path between them in either direction. This would only result in 3320 traversals in the worst case, which would take much less time. 
### 3.AI prompts used
Generate a function that returns the UNIX timestamp as an integer
### 4. Code explanation. Emphasize high level intuition (include code)
The code first randomly selects a number between 0 and the size of the number of airports in the map, then iterates over the airports in the map until it reaches that generated number. Next, it iterates over the airports again and runs the shortest path function on the two airports. If there is no path, it then runs the function again but in the reverse direction. If there is no path in either direction, the graph is not connected and the function returns false. If the function makes it through the entire graph without stopping, the graph is connected.
```cpp
bool isWeaklyConnected(unordered_map<string, set<string>> aList) {
    int numNodes = aList.size();
    int startNum = rand() % numNodes;
    string v1;
    int i = 0;    
    for (const auto & airport : aList) {
        if (i==startNum) {
            v1 = airport.first;
            break;
        }
        i++;
    }
    bool connected = true;
    for (const auto & it : aList) {
        string v2 = it.first;
        if (v1==v2) continue;
        
        if (lookupShortestPath(aList, v1, v2).distance == -1) {
            // Checks for weak connection
            if (lookupShortestPath(aList, v2, v1).distance == -1) { 
                println(v2 + " is not connected to " + v1 + "\n");
                connected = false;
                break;
            }
        }
    }
    return connected;
}
```
### 5.Code testing (Include test code)

I spent a lot of time trying to figure out what was wrong with my function, because it kept determining that the graph was disconnected, even though my intuition told me that the vast and dense graph of all flights between all airports should be connected. Eventually, I added the line that prints out the combination of airports that makes it fail, and then I looked up the airports on the openflights website. As it turns out, there are a few networks of airports, like this one off the Eastern coast of Australia, that only operate flights to each other and nowhere else. This means that the graph really is disconnected, and my code was right all along.
![[Pasted image 20240623224916.png]]
```cpp
void seedRand() {
    // Get the current time point using chrono library
    auto now = chrono::system_clock::now();

    // Convert the time point to duration since epoch
    auto duration = now.time_since_epoch();

    // Convert duration to seconds (Unix timestamp)
    auto unix_time = chrono::duration_cast<chrono::seconds>(duration).count();

    // Convert Unix time to an integer type suitable for random seed
    uint_fast32_t seed = static_cast<uint_fast32_t>(unix_time);

    srand(seed);

}

int main() {
    seedRand();
    unordered_map<string, set<string>> routeMap = getAdjList("routes.dat");

    string source;

    cout << endl << (isWeaklyConnected(routeMap) ? "This graph is connected" : "This graph is not connected");

    while (true) {

        while (true) {
            println("Enter source airport ");
            cin >> source;
            if (routeMap.find(source)==routeMap.end()) {
                println("Invalid source airport code");
            }
            else break;
        }

        string destination;

        while (true) {
            println("Enter destination airport ");
            cin >> destination;
            if (routeMap.find(destination)==routeMap.end()) {
                println("Invalid destination airport code");
            }
            else break;
        }

        path shortestPath = lookupShortestPath(routeMap, source, destination);

        if (shortestPath.distance==-1) {
            cout << "There is no valid path between " << source << " and " << destination << endl; 
        }
        else {

            cout << endl << "The most direct path from " << source << " to " << destination << " requires " << shortestPath.distance << " stop" << (shortestPath.distance == 1 ? "." : "s.") << endl;
            cout << "This path is as follows: ";
            printVec(shortestPath.path);
        }

        cout <<endl;
    }


    return 0;
}

```
### 6.Alternate solutions if attempted
I didn't want to wait for this code to finish
```cpp
bool isWeaklyConnectedOn2(unordered_map<string, set<string>>& aList) {
    for (const auto & src : aList) {
        for (const auto & dest: aList) {
            if (src.first == dest.first) continue;
            if (lookupShortestPath(aList, src.first, dest.first).distance == -1) {
                if (lookupShortestPath(aList, dest.first, src.first).distance == -1) return false;
            }
        }
    }

    return true;
}
```

For class #data-structures 