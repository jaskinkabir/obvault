Continues [[CPU Pipelining-Multicycle Execution]]
Continued by [[Control Hazards and Branch Prediction]]
# Pipelined Datapath Diagram
![[Pasted image 20241028180453.png]]
## Data Hazard
- Also called **Pipeine Data Hazard**
- Need to wait for previous instruction to complete its data operation
	- The planned instruction cannot execute in the proper clock cycle because data needed to execute the instruction is not yet available
### Stalling
- Example:
	- ![[Pasted image 20241023175953.png]]
	- The row of bubbles represents a no-op
		- This is required to ensure the decode stage accesses the proper values in the register file
	- The blue line represents a forwarding connection
	- In this case, the subtraction cannot be executed because the result of the load operation is not yet available
		- The data has not entered the Write-Back stage yet at $T=800$
### Forwarding (aka Bypassing)
- ![[Pasted image 20241023180356.png]]
- This technique can be used to resolve data hazards
- It retrieves the missing data element from internal buffers rather than waiting for it to arrive from programmer-visible registers or memory
- Implemented by connecting the ALU output from the first instruction back into the ALU input for the second instruction
	- Requires extra connections in the datapath
- Forwarding can be done with 4 different assignments
	- 1a: EX/MEM.RegisterRd = ID/EX.RegisterRn1
	- 1b: EX/MEM.RegisterRd = ID/EX.RegisterRm2
	- 2a: MEM/WB.RegisterRd = ID/EX.RegisterRn1
	- 2b: MEM/WB.RegisterRd = ID/EX.RegisterRm2
		- For some reason the notation is backwards
- A type 1 data hazard requires forwarding from the ALU output back to the input, type 2 forwards from memory output
	- Type 1 is 1 instruction directly after another. Type 2 has an instruction in between
	- A space of 2 instructions creates no hazard
### Load-Use Data Hazard
- This is called a **Load-Use** hazard because the data from a load operation is used in the very next instruction
- Stalls must be used for Load-Use hazards
	- A forward might also need to be used
- Consider this example![[Pasted image 20241023181202.png]]
	- If the `SUB` instruction were to be fetched the cycle after the `LDUR` instruction, the `SUB` instruction would reach the EX stage before the data was available at the memory output
	- This means that the second instruction must be offset, or delayed, by one clock cycle
		- This is done by adding a no-op to the pipeline
	- Now, the `SUB` instruction reaches the EX stage after the `LDUR` instruction completed its MEM stage
### Code Scheduling to Avoid Stalls
- Consider the following code
```c
0: LDUR _X2 [X0, #8]
1: ADD X3, X1, _X2
2: LDUR __X4, [X0, #16]
3: ADD X5, X1, __X4
```
- I1 requires the loaded data from I0, and I3 from I2
- This means that I1 and I3 will require no-ops to occur before they can be executed
- This can be fixed by reordering the sequence:
```c
0: LDUR _X2, [X0, #8]
1: LDUR __X4, [X0, #16]
2: ADD X3, X1, _X2
3: ADD X5, X1, __X4
```

# Forwarding Implementation
- The two ALU inputs now receive data from 3to1 MUXes controlled by the 2-wire signals ForwardA and ForwardB
- These inputs are generated by the forwarding unit
	- Its input signals are:
		- ID/EX.RegisterRn1
		- ID/EX.RegisterRm2
		- EX/MEM.RegisterRd
		- MEM/WB.RegisterRd
		- EX/MEM.RegWrite

| MUX Control | Source Reg | Source Component   |
| :---------- | :--------- | :----------------- |
| 00          | ID/EX      | Register File      |
| 01          | MEM/WB     | Data Memory Output |
| 10          | EX/MEM     | ALU Output         |
- For some ungodly reason the bits for 1 represents the data memory and 2 represents ALU output
	- Remember that it's reversed. ARM designers are dumb and stupid
# Data Hazard Detection
Consider:
```c
SUB X2, X1, X3
AND X12, X2, X5
OR X13, X6 X2
ADD X14, X2, X2
STUR X15, [X2. #100]
```
![[Pasted image 20241030174933.png]]
- The 2nd and 3rd instructions require X2 to be forwarded from the 1st instruction
- To detect a forwarding need: pass register numbers along the pipeline
## Data Hazard Conditions
### EX
```verilog
if (
		 EX/MEM.RegWrite
	and (EX/MEM.RegisterRd != 31)
	and (EX/MEM.RegisterRd == ID/EX.RegisterRn1)
) ForwardA = 10

if (
	EX/MEM.RegWrite
	and (EX/MEM.RegisterRd â‰  31)
	and (EX/MEM.RegisterRd == ID/EX.RegisterRm2)
) ForwardB = 10

```

### MEM
```verilog
if (
		 MEM/WB.RegWrite
	and (MEM.WB.RegisterRd != 31)
	and (MEM.WB.RegisterRd == ID/EX.RegisterRn1)
) ForwardA = 01

if (
		 MEM/WB.RegWrite
	and (MEM.WB.RegisterRd != 31)
	and (MEM.WB.RegisterRd == ID/EX.RegisterRm2)
) ForwardB = 01			 
```
- The condition `EX/MEM.RegWrite` checks if the result of the instruction that is currently at the ALU output will be written into the register file
	- If it is not, then no data hazard has occurred
	- This is the same for the MEM hazard detection 
- Note that these conditions make an exception for when the destination register is `XZR`, since no data hazard can happen with a constant register
- These conditions do not need to know anything about the order of instructions, they are based solely on the instantaneous state of the processor
- 
## Data Hazard Types
1. _
	1. 1a: EX/MEM.RegisterRd = ID/EX.RegisterRn1
	2. 1b: EX/MEM.RegisterRd = ID/EX.RegisterRm2
2. _
	1. 2a MEM/WB.RegisterRd = ID/EX.RegisterRn1
	2. b MEM/WB.RegisterRd = ID/EX.RegisterRm2
- Type 1 Hazard means the required source value is in the EX/MEM Register
	- The hazardous instruction is the very next instruction
- Type 2 Hazard means the required source value is in the MEM/WB Register
	- The hazardous instruction is one after the very next instruction
## Double Data Hazard
Consider: 
```C
ADD X1, X1, X2
ADD X1, X1, X3
ADD X1, X1, X4
```
- I2 (Instruction 2) requires the value `X1`, which is currently in the EX/MEM stage of I1
- I3 requires `X1` as well, but this value is in both the MEM/WB stage of I1 and the EX/MEM stage of I2
- Since EX/MEM has the most recent value of `X1`, this should be chosen as the source for forwarding
- **EX/MEM TAKES PRIORITY IN A DOUBLE DATA HAZARD**
# Stalling
## Stall Implementation
- To cause a stall, the following procedure must be executed
	- Set instruction register to all 0s
		- ID/EX Register = 0
	- Prevent update of PC and IF/ID register
		- Keep same value
		- Instruction is decoded again
		- Next instruction is fetched again
- To achieve this, the following output signals must be generated by the hazard detection unit
	- ID.FLUSH
		- Controls whether the ID/EX Register is updated with the values from the IF/ID Register or set to all 0s
	- IF/IDWrite
		- Controls whether the IF/ID Register is updated
	- PCWrite
		- Controls whether the PC Register is updated
## Stall Detection
- The hazard Detection unit is required to detect Load-Use hazards and initiate a stall
- Its inputs are:
	- ID/EX.MemRead
	- ID/EX.RegisterRd
	- IF/ID.RegisterRn1
	- IF/ID.RegisterRm2
- The condition it checks is as follows
```python
if (
	ID/EX.MemRead 
	and (
		   (ID/EX.RegisterRd == IF/ID.RegisterRn1)
		or (ID/EX.RegisterRd == IF/ID.RegisterRm2)
	)
) {
   ID/EXSRC = 1
   IF/IDWrite = 0
   PCWrite = 0
}
```
- Check if the instruction currently being executed will read memory into the register file
- Then check if the destination register is equal to either source register of the instruction currently being decoded
# Datapath With Forwarding
![[Pasted image 20241030180931.png]]

For class #comporg