Based on [Parsing and Visitors](https://libcst.readthedocs.io/en/latest/tutorial.html) [Parsing](https://libcst.readthedocs.io/en/latest/parser.html#libcst.parse_expression) [Best Practices](https://libcst.readthedocs.io/en/latest/best_practices.html)
## Parsing:
 LibCST provides the following parsing functions
### Parse module
 `libcst.parse_module(source: str | bytes, config: PartialParserConfig = PartialParserConfig()) → Module`
 
 This is the most useful as it takes an entire file and generates a tree
 It includes all leading and trailing whitespace, as well as comments
 
 From docs, there is a specific procedure for calling this function on a Module object generated by libCST
 
 It is recommended that when calling [`parse_module()`](https://libcst.readthedocs.io/en/latest/parser.html#libcst.parse_module "libcst.parse_module") with a string you access the serialized code using [`Module`](https://libcst.readthedocs.io/en/latest/nodes.html#libcst.Module "libcst.Module")’s code attribute, and when calling it with bytes you access the serialized code using [`Module`](https://libcst.readthedocs.io/en/latest/nodes.html#libcst.Module "libcst.Module")’s bytes attribute. 
### Parse Expression
 `libcst.parse_expression(source: str, config: PartialParserConfig = PartialParserConfig())→ BaseExpression`
 
 Leading and trailing whitespace is not valid as the expression node has no place to store it

### Parse Statement
 `libcst.parse_statement(source: str, config: PartialParserConfig = PartialParserConfig())→ SimpleStatementLine | BaseCompoundStatement`
 
 The source must be followed by a trailing newline
 If not provided, a trailing newline will be added
 
 Leading and trailing comments (On the same line) are accepted, but any whitespace or anything else after the statement's trailing newline is not valid
 
 Thus code rendered out/generated from a parsed statement using `cst.Module([]).code_for_node(statement)` will not include leading/trailing comments.
 
## Visitors and Transformers
 Both have methods that define what to do when entering and leaving a node
### Visit Methods:
Take a node as its only argument and optionally returns a bool
Optional means return value can be None
### Leave Methods
 A visitor's leave method takes a node as an argument and optionally returns a bool
 
 A transformer, however, will take a second argument which is a copy of the visited node.
 
 Instead of an optional bool, it returns the updated node
 Once the updated node is returned, it will replace the old node in the tree.
 
 To leave a node unchanged, simply return the updated node without changes
 
 Passing a transformer to a tree's visit function will modify it in place according to the methods defined by the transformer.
 
 Passing a visitor will make no changes to the tree
 
### Why Return Updated Node?
 Trees are immutable. The only way to modify a tree is to construct a new one. 
 Let's say a transformer is going to rename every function. It creates a leave_call function that renames the value of the original node's func.name, and then returns that node
 
 Let's say the transformer is applied to a function call that calls another function to load its arguments: `some_func(1, 2, other_func(3))`
 When the transformer is walking the tree, it will reach the call statement within the outer call statement first, and then add the returned node from `original_node.with_changes()` to the **updated tree** (Remember that trees are immutable!)
 Then the transformer leaves the sub-call and calls the leave_call method for the outer call. When it accesses the `original_node`, it's accessing a node whose sub-call does not have the modification. This means that when the modification is made to this `original_node`, the updated tree will discard any changes made deeper in the tree
 If our transformer works on and returns the original node, the code snippet will see the following unwanted transformation `renamed_some_func(1, 2, other_func(3))`
 If the updated_node is worked on and returned, the expected functionality is achieved. `renamed_some_func(1, 2, renamed_other_func(3))`
 ![[Pasted image 20240709202714.png]]
## Source Code Generation
 The `tree.code`attribute stores the source code that is represented by a cst tree
 The tree class also has a method called `deep_equals` that can be called to check if two trees represent the same source code. For example:
``` python
if not modified_tree.deep_equals(source_tree):
	file.write(modified_tree.code)
```



Topic #LibCST